1. JOIN -FROM절에서 묶어준다
	두 개이상의 테이블을 연결하여 데이터를 검색하는 방법
	여러 테이블(정규화)에 흩어져 있는 정보 중 사용자가 필요한 정보만 가져와서
	가상의 에이블처럼 만들고 결과를 보여주는 것 -> 코드의 간편성 때문에 3차 정규화까지만 사용한다 
	
	정규화를 통해 조회 테이블이 너무 많이 쪼개져 있으면 작업이 불편하기 때문에
	입력, 수정, 삭제의 성능을 향상시키기 (쿼리를 간편하게한다)위해 JOIN을 통해 합친 후 사용한다
	

- 모델링 > 정규화 > 이상현상
	
	이상현상 : 데이터베이스의 설계가 잘못되어 발생
	- 삽입이상
	- 갱신이상
	- 삭제이상

	 무결성의 종류
	- 개체 무결성	: 모든 테이블이 PK로 선택된 컬럼을 가져야한다
	- 참조 무결성	: 두 테이블의 데이터가 항상 일관된 값을 가지도록 유지하는 것(부모테이블의 PK-자식테이블의 FK 일치)
	- 도메인 무결성	: 컬럼의 타입, NULL 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지를 확인하는 것
	



1) JOIN의 종류 -> 가로로 합쳐진다 
	내부조인 : 공통 존재 컬럼의 값이 같은 경우 추출하는 기법
	
	외부조인
		- 왼쪽 외부조인 : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일데이터를 추출하는 기법
		- 오른쪽 외부조인 : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출하는 기법
		- 완전 외부조인 : 양쪽의 모든 데이터를 추출하는 기법
	교차조인 : 조인조건이 없는 모든 데이터 조합을 추출하는 기법
	셀프조인 : 자기자신에게 별칭을 지정한 후 다시 조인하는 기법

2) 내부조인 (INNER JOIN)
	조건이 정확히 일치하는 값만 합쳐서 조회
	선행테이블에 있는 행의 개수가 적은 게 좋다 WHY? 
	-> 선행테이블에서 테이블 하나하나 후행테이블에 비교하기 때문에 적으면 그만큼 시간도 적게 걸린다 	

	SELECT A.컬럼명1, A.컬럼명2, B.컬럼명1, B.컬럼명2
	FROM 테이블명1 A, [INNER] JOIN 테이블명2 B
	ON [조인조건] -- A.컬럼명1 = B.컬럼명1;
	[WHERE 검색조건]
	
3) 등가조인 
	두 테이블간의 컬럼의 값이 서로 일치 할 때, ON절에 등호(=)가 있을 때
	일반적으로 PK <-> FK 관계를 이용하여 조인을 주로 사용한다
	두 테이블간에 관계가 있다면(FK가 존재한다면) 부모 테이블간의 
	PK와 자식테이블의 FK를 등호로 비교가 가능하기 때문에 등가조인 사용이 가능하다

- 비등가조인
	두 테이블의 특정 컬럼이 일치하지 않는 경우, ON절에 등호(=)가 없을 때 사용
	= 연산자가 아닌 BETWEEN, > , >=, < , <= 등의 연산자를 사용
	

※※※※※SQL 실행순서※※※※※※
FROM -> ON -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY
 FROM : 테이블이나 뷰의 데이터 가져오기
 ON : JOIN절의 조건 평가
 JOIN : 지정된 조건에 따라 두 개 이상의 테이블을 조인
 WHERE : 조인 결과에서 조건에 맞는 행을 필터링
 GROUP BY : 데이터 그룹화(집계함수와 주로 사용)
 HAVING : GROUP BY로 그룹화된 데이터에 대해 조건 적용
 SELECT : 조회할 컬럼을 선택(집계함수, 별칭)
 ORDER BY : 최종 결과를 정렬(ASC, DESC)

+) ON절의 조건은 JOIN이 되면서 실행되고, WHERE 절의 조건은 JOIN이 모두 끝나고 나서 실행된다
	ON절과 WHERE을 같이 사용할 때와 ON절만 사용했을 때의 결과가 같다면 ON절만 사용하는 것이 좋다
	
4) 외부조인(OUTER JOIN)
	외부조인은 내부조인과 다르게 한쪽에만 값이 있아도 테이블을 합쳐서 보여준다
	외부조인 나눈 이유 :  	

- 왼쪽 외부조인 : 왼쪽테이블 기준 / 오른쪽 테이블에 일치하는 컬럼이 없을 때는 오른쪽의 컬럼값은 NULL로 채워진다
	SELECT A.칼럼1, A.칼럼2, B.칼럼1, B.칼럼2		EX) 도서테이블 A= 번호 책이름	B= 번호 책가격
	FROM 테이블1 A LEFT [OUTER] JOIN 테이블2 B				1 ㅁ		1 100
	ON 조건조건							2 ㄴ		2 200
	[WHERE 검색조건];							3 ㅇ		3 3000
 									5 ㅛ
								출력 : 번호 책이름 책가격
									1 ㅁ 100
									2 ㄴ 200
									3 ㅇ 3000 																	5 ㅛ NULL
		
- 오른쪽 외부조인 : 오른쪽테이블 기준 / 왼쪽테이블에 일치하는 컬럼이 없을 때는 왼쪽의 컬럼값은 NULL로 채워진다
	SELECT A.칼럼1, A.칼럼2, B.칼럼1, B.칼럼2
	FROM 테이블1 A RIGHT [OUTER] JOIN 테이블2 B
	ON 조인조건
	[WHERE 검색조건];		

   A.책번호 A.책이름 B.책번호 B.가격
   1   aaa   1   100
   3   ccc   3   300
   null   null   4   500



- 완전 외부조인
	SELECT A.칼럼1, A.칼럼2, B.칼럼1, B.칼럼2
	FROM 테이블1 A FULL [OUTER] JOIN 테이블2 B
	ON 조인조건
	[WHERE 검색조건];	

   A.책번호 A.책이름 B.책번호 B.가격
   1   aaa   1   100
   2   bbb   null   null
   3   ccc   3   300
   null   null   4   500


2. 집합 -> 세로 방향으로 합쳐진다
	UNION : 합집합 -> 중복을 허용하지 않는다
	UNION ALL : 합집합, 중복을 허용한다
	INTERSECT : 교집합
	MINUS : 차집합

집합연산자가 있는 이유 :
	데이터 베이스에서 여러쿼리의 결과를 조합하고 특정 방식으로 결과를 출력하기 위해 존재 
	여러 테이블이나 쿼리의 결과를 효과적으로 비교, 병합, 차집합 등으로 처리해야하는 데이터의 요구사항 때문에 존재한다
					
	하나의 테이블에서 WHERE절을 사용하면 특정 조건을 만족하는 데이터를 조회할 수 있지만
	집합 연산이 필요한 경우가 다르기 때문에 따로 알아야 한다.

		집합연산					WHERE 조건
쿼리실행방식	각 SELECT쿼리가 독립적 실행			단일 쿼리로 실행
결과처리		개별 쿼리 결과를 결합비교			조건 필터링만 수행
중복제거여부	UNION 중복제거, UNION AL 중복제거X		중복 제거는 따로 수행하지 않음
데이터소스		여러테이블, 쿼리조합가능			단일 테이블에서 작동
성능		SORT, 비교등의 추가단계가 느릴수 있음		단일 조건을 처리해서 비교적 빠르다
사용목적		독립된 결과를 병합 OR 차집합,교집합 구할때 	단일 테이블에서 특정 조건만 필터링
							
	
	SELECT EMP_ID FROM EMP_A e
	UNION
	SELECT EMP_ID FROM EMP_B e							
	
	1) EMP_A에서 EMP_ID를 읽어서 첫번째 결과 집합 생성
	2) EMP_B에서 EMP_ID를 읽어서 두번째 결과 집합 생성	
	3) 두 결과 집합을 결합하고 중복 제거(정렬단계 포함)
	4) 최종 결과 반환		

	SELECT EMP_ID FROM EMP
	WHERE DEPT_ID = 10 AND SAL >= 3000;
		
	SELECT COALESCE(E1,ENP_ID, E2.ENP_ID) AS EMP_ID
	FROM EMP_A E1
	FULL OUTER JOIN EMP_B E2
	ON E1.EMP_ID = E2.EMP_ID;

	+) 참고 COALESCE
	다중값을 평가하고 NULL을 효과적으로 대체하기 위한 도구
	첫 번째 NULL이 아닌 값을 반환하며 모든 인수가 NULL인 경우 결과도 NULL이 된다
	주로 FULL OUTER JOIN 결과를 병합하거나 NULL을 처리할 때 사용된다

3. 형 변환 함수
	TO_CHAR(): CHAR형으로 변환
	날짜형식 변경할 때 유용하다
	TO_CHAR(STSDATE, 'YYYY-MM-DD')
	형식 : 'YYYYMMDD', 'YYYY/MM/DD'
	년 : YYYY, 월 : MM, 일 : DD
	24시간 : HH24, 12시간 : HH, 분: MI, 초 : SS

	TO_NUMBER() : NUMBER형으로 변환
 	TO_DATE() : DATE형으로 변환

4. VIEW - 보안성 강화 
	기존의 테이블은 그대로 놔둔 채 필요한 컬럼들 및 새로운 컬럼을 만들 가상 테이블
 	실제 데이터가 저장되는 것은 아니지만 VIEW를 통해서 데이터를 관리할 수 있다
	
1) VIEW를 사용하는 이유
	- 보안성 : 기존의 쿼리문이 보이지 않으며, 권한을 가진 사람들만 접근할 수 있도록 따로 제한 해줄 수 있다
	- 독립성 : 다른 곳에서 원본 테이블에 접근하지 못하도록 하는 성질
	- 편리성 : 긴 쿼리문 짧게 만드는 성질

2) VIEW 문법 
	- VIEW 생성	
	CREATE VIEW 뷰 이름 AS 쿼리문; => CREATE는 DB정의할 때 있다

	- VIEW 사용
	SELECT * FROM 뷰이름;
	
	-VIEW 삭제
	DROP VIEW 뷰이름;


 
3) VIEW 특징
	가상테이블 : 데이터를 실제로 저장하지 않으며 원본테이블에서 데이터를 가져와 동적으로 생성된다
	재사용가능 : 자주 사용되는 복잡한 쿼리를 뷰로 정의하여 반복적으로 사용할 수 있다
	데이터 필터링 : 사용자가 필요한 데이터만 볼 수 있도록 제한 할 수 있다 
	데이터 보안 : 민감정보를 숨기거나 특정 사용자에게 제한된 데이터만 제공할 수 있다 

4) VIEW와 보안과 관계
	민감데이터 제외
	사용자의 권한을 제한
	데이터 마스킹 처리 - 특정 데이터를 가공해서 안 보이게 하는 것
	그룹에 대해서 권한 부여 가능 -> 팀 1 팀 2 팀 3 별로 다르게 부여
	서브쿼리 조인 사용해서 많이 사용하는데 문제가 발생 할 수 있다.	

5. DCL : 대아토 재어 언어
	데이터 베이스에 접근하는 권한을 제어하는 명령어
	GRANT	계정에 권한을 부여하는 명령어
		GRANT 권한 ON 테이블명 TO 계정명;

	REVOKE 계정에 권한을 회수(제거)하는 명령어	
		REVOKE 권한 ON 테이블명 FROM 계정명;	

- 계정만들기 
	SYS 계정으로 접속해서 계정을 생성한다 
	CRAEATE USER 계정명 IDENTIFIED BY 비밀번호;

- CREATE SESSION 권한 부여하기 
	GRANT CREATE SESSION TO 계정명;

- 현재 계정의 권한 확인하기
	SELECT * FROM USER_TAB_PRIVS_RECD;

-현재 계정이 부여한 권한 확인하기
	SELECT * FROM USER_TAB_PRIVS_MADE;

-계정 삭제
	DROP USER 계정명;


6. TCL : 트랜잭션(두개가 동시에 실행) 제어어
	트랜잭션 : 하나의 작업단위 - 여러개의 쿼리문(SQL문)의 묶음
	COMMIT : 모든 작업(트랜잭션)을 확정짓는 명령어
	ROLLBACK : 이전 커밋 시점으로 되돌아가는 명령어
	
7. CASE 표현식
	조건식이 만족하면 결과값을 얻는다
	모든 조건식을 만족하지 않으면 기본값을 얻는다	
	ELSE 생략시 NULL을 기본값으로 사용한다
	
	조건1을 만족하는 행은 값1을 결과로 갖는다
	조건2를 만족하는 행은 값2를 결과로 갖는다
	...
	위의 조건을 만족하지 않는 행은 ELSE의 값을 결과로 갖는다
	ELSE를 생략하면 모든 조건을 만족하지 않는 경우 NULL이 들어간다 

	CASE 
		WHEN 조건식1 THEN 결과값1
		WHEN 조건식2 THEN 결과값2
		...
		ELSE 기본값
	END
---? SELECT 할때 사용 
























		